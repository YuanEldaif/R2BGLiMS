% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/JAMPred.R
\name{JAMPred}
\alias{JAMPred}
\title{JAMPred}
\usage{
JAMPred(marginal.betas = NULL, n.training = NULL,
  marginal.logor.ses = NULL, p.cases.training = NULL, ref.geno = NULL,
  total.snps.genome.wide = NULL, n.cores = 2, n.mil = 0.2,
  beta.binom.b.lambda = 1, beta.binom.a = 1, snps.blocks = NULL,
  initial.block.size = 100, initial.snps.blocks = NULL, seed = NULL,
  thinning.factor = round(1000/n.mil))
}
\arguments{
\item{marginal.betas}{Vector of named one-at-a-time SNP effects. NB: This must be a named vector; it is where.
the SNP names are derived from. These could be from linear regressions, or log-Odds Ratios. 
NB: If providing log-ORs, you must also provide marginal.logor.ses and p.cases.training so
that a linear transformaiton can be applied.}

\item{n.training}{The sample size in which the marginal.betas were calculated.}

\item{marginal.logor.ses}{IF marginal log-ORs were provided, please provide a named vector of standard errors here.
These are necessary to convert them to a linear scale. Do not set if providing linear regression estimates.}

\item{p.cases.training}{IF marginal log-ORs were provided, please provide the proportion of cases in the sample in
which they were calculated}

\item{ref.geno}{Reference genotype matrix which will be used to calculate SNP-SNP correlations. Individual's genotype 
must be coded as a numeric risk allele count 0/1/2. Non-integer values reflecting imputation uncertaimnty may be given. 
NB: The risk allele coding MUST correspond to that used in marginal.betas and column names must match the names of
marginal.betas elements.}

\item{total.snps.genome.wide}{Total number of SNPs being analysed across the genome. Used to determine the level of
prior sparsity.}

\item{n.cores}{Number of CPU cores to use. Default is 2.}

\item{n.mil}{Number of million iterations to run. In the paper we found 0.2 was sufficient to reach adequeate
convergence.}

\item{beta.binom.b.lambda}{Spartisty tuning parameter. Suggest a range of values is tried, e.g. 0.01, 0.1, 1, 10.
See the paper for more detail. Default is 1.}

\item{beta.binom.a}{First hyper-parameter of the beta-binomial prior on model sparsity. See the paper for more detail. Default 1 can usually
be used.}

\item{snps.blocks}{OPTIONAL: A partitioning of the SNPs into blocks, created using the function 
\code{\link[R2BGLiMS]{JAMPred_SplitIntoPositiveDefiniteBlocks}}. This is automatically generated 
if not provided.}

\item{initial.block.size}{Block size for the initial partitioning. Default is 100. This is ignored when initial.snps.blocks is given.}

\item{initial.snps.blocks}{A user specficied initial partitioning of the SNPs. This must be a list, each element of which is a vector of SNP
names that correspond to the columns of ref.geno. This could be defined, for example, according to LD information.}

\item{seed}{An integer specifying the RJMCMC seed. If not set a random number will be used every time this is run.}

\item{thinning.factor}{Determines every ith iteration to use from the RJMCMC sample. The more thinning that is applied
the quicker the analysis will be, for the same number of iterations. Leaving at the default should be fine.}
}
\value{
A JAMPred results object, which is a list including as elements step1.posterior.mean.snp.weights 
(which do not adjust for long range LD) and step2.posterior.mean.snp.weights (which do adjust for long 
range LD). These SNP weights can be used to generate predictions from individual level genotype data.
}
\description{
This function runs JAMPred by analysing many SNP blocks independently in parallel.
}
\examples{
# --- Load libraries
library(R2BGLiMS)
data("JAMPRED_Example")

###########################################################
# --- Simple demonstation of syntax for binary traits --- #
###########################################################
# NB: See third example for modelling different chromosomes and sparsities

# Run JAMPred
snps <- chromosome.snps[[1]] # Only use chromosome 1 data
jam.pred.res <- JAMPred(
  marginal.betas = marginal.logors[snps],
  n.training = n.training,
  marginal.logor.ses = marginal.logor.ses, # Only necessary for a binary trait
  p.cases.training = n.cases.training/n.training, # Only necessary for a binary trait
  ref.geno = data.validation[,snps],
  total.snps.genome.wide = 500000, # Total SNPs across all chromosomes
  n.mil = 0.2
)

# Generate predictions
out.of.sample.predictions <- 
  data.validation[,jam.pred.res$snps] \%*\% 
  jam.pred.res$step2.posterior.mean.snp.weights

# Predictive r2
cor(out.of.sample.predictions, data.validation[,"d"])^2

###########################################################
# --- Simple demonstation of syntax for binary traits --- #
###########################################################
# NB: See third example for modelling different chromosomes and sparsities

# Run JAMPred
snps <- chromosome.snps[[1]] # Only use chromosome 1 data
jam.pred.res <- JAMPred(
  marginal.betas = marginal.ctsbetas[snps],
  n.training = n.training,
  ref.geno = data.validation.cts[,snps],
  total.snps.genome.wide = 500000, # Total SNPs across all chromosomes
  n.mil = 0.2
)

# Generate predictions
out.of.sample.predictions <- 
  0 + # NB: A trait mean could be set here (otherwise it is assumed the outcome is mean-centred)
  data.validation.cts[,jam.pred.res$snps] \%*\% 
  jam.pred.res$step2.posterior.mean.snp.weights

# Predictive r2
cor(out.of.sample.predictions, data.validation.cts[,"y"])^2

##################################################################################
# --- Using JAMPred to model multiple chromosomes under different sparsities --- #
##################################################################################

# Run JAMPred, looping over sparsities and chromosomes
jam.pred.res <- list() # List to hold all the results
for (lambda in c(0.01, 0.1, 1, 10)) { # Loop over lambda choices (see the paper)
  jam.pred.res[[paste(lambda)]] <- list()
  for (chr in c(1:2)) { # Loop over chromosomes
    jam.pred.res[[paste(lambda)]][[chr]] <- JAMPred(
      marginal.betas = marginal.logors[chromosome.snps[[chr]]],
      n.training = n.training,
      marginal.logor.ses = marginal.logor.ses,
      p.cases.training = n.cases.training/n.training,
      ref.geno = data.validation[,chromosome.snps[[chr]]],
      total.snps.genome.wide = 500000,
      n.mil = 0.2,
      beta.binom.b.lambda = lambda,
      initial.block.size = 100, # Default size of SNP blocks
      n.cores = 2  # Number of cores on your computer 
    )
  }
}

# Generate predictions for each lambda, summing predictive scores over chromosoms
out.of.sample.predictions <- list()
for (lambda in c(0.01, 0.1, 1, 10)) {
  out.of.sample.predictions[[paste(lambda)]] <- 0
  for (chr in c(1:2)) {
    out.of.sample.predictions[[paste(lambda)]] <-
      out.of.sample.predictions[[paste(lambda)]] +
      data.validation[,jam.pred.res[[paste(lambda)]][[chr]]$snps] \%*\% 
      jam.pred.res[[paste(lambda)]][[chr]]$step2.posterior.mean.snp.weights
  }
}

# Predictive r2
sapply(out.of.sample.predictions, function(preds) cor(preds,data.validation[,"d"])^2)
# Predictive correlation highest at lambda = 0.01
}
\seealso{
See \code{\link{JAMPred_SplitIntoPositiveDefiniteBlocks}}; this is the function used to create an initial 
partitioning of SNPs into blocksm which satisfy the property of all being positvie definite with respect to the 
reference genotype matrix (also required by JAMPred). By default this function is used to generate the snps.blocks
list input, if not provided by the user.
}
\author{
Paul Newcombe
}
